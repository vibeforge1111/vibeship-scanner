## Memory (Mind)

This project uses Mind for persistent memory across sessions.

### Required Protocol

1. **Session Start**: ALWAYS call `mind_recall()` before responding to the first message. This loads context from previous sessions.

2. **During Work**: Use `mind_log(message, type)` to capture what happens:
   - `mind_log("chose X over Y - simpler", type="decision")` → MEMORY.md
   - `mind_log("API returns 500 on large payloads", type="problem")` → MEMORY.md
   - `mind_log("Safari needs vendor prefix for X", type="learning")` → MEMORY.md
   - `mind_log("resolved by increasing timeout", type="progress")` → MEMORY.md
   - `mind_log("working on auth flow", type="experience")` → SESSION.md
   - `mind_log("build keeps failing", type="blocker")` → SESSION.md
   - `mind_log("tried Redis - too complex", type="rejected")` → SESSION.md
   - `mind_log("assuming user has stable internet", type="assumption")` → SESSION.md

3. **Session End**: Summarize with `## DATE | what happened | mood: X`

### Two-Layer Memory

**MEMORY.md** (permanent, cross-session):
- Decisions, learnings, problems, progress
- Use types: `decision`, `learning`, `problem`, `progress`

**SESSION.md** (ephemeral, within-session):
- Raw experience, blockers, rejected approaches, assumptions
- Use types: `experience`, `blocker`, `rejected`, `assumption`
- Valuable items get promoted to MEMORY.md on session gap (>30 min)

### Tools Available

- `mind_recall()` - Load session context (CALL FIRST!)
- `mind_log(msg, type)` - Log to session or memory (routes by type)
- `mind_session()` - Get current session state
- `mind_blocker(description)` - Log blocker + auto-search memory for solutions
- `mind_search(query)` - Find specific memories
- `mind_remind(msg, when)` - Set time or context reminder
- `mind_checkpoint()` - Force process pending memories
- `mind_edges(intent)` - Check for gotchas before coding
- `mind_status()` - Check memory health
- `mind_spawn_helper(problem)` - Package problem for fresh agent investigation

---

<!-- MIND:CONTEXT - Auto-generated by Mind. Do not edit. -->
## Stack
sveltekit, typescript, supabase

## Gotchas
(None yet - add to .mind/MEMORY.md Gotchas section)
<!-- MIND:END -->

# CLAUDE.md - Vibeship Scanner Development Guide

This file provides guidance to Claude Code when working with this repository.

## Project Overview

Vibeship Scanner is a security scanning tool that analyzes GitHub repositories for vulnerabilities using:
- **Opengrep** - Static Application Security Testing (SAST) - open-source Semgrep fork
- **Trivy** - Dependency vulnerability scanning
- **Gitleaks** - Secret detection

## IMPORTANT: How to Trigger Scans

**ALWAYS use the deployed Vibeship Scanner API for scans** - never run local semgrep/opengrep commands directly.

### Scan Procedure (MUST FOLLOW)

```bash
# 1. Generate a UUID for the scan
SCAN_ID=$(python -c "import uuid; print(uuid.uuid4())")

# 2. Trigger the scan via curl
curl -X POST https://scanner-empty-field-5676.fly.dev/scan \
  -H "Content-Type: application/json" \
  -d "{\"scanId\": \"$SCAN_ID\", \"repoUrl\": \"https://github.com/OWNER/REPO\"}"

# 3. Provide the scan URLs to the user
echo "View at: http://localhost:5173/scan/$SCAN_ID"
echo "View at: https://scanner.vibeship.co/scan/$SCAN_ID"
```

### Quick One-Liner Template
```bash
SCAN_ID=$(python -c "import uuid; print(uuid.uuid4())") && \
echo "Scan ID: $SCAN_ID" && \
echo "View at: http://localhost:5173/scan/$SCAN_ID" && \
echo "View at: https://scanner.vibeship.co/scan/$SCAN_ID" && \
curl -X POST https://scanner-empty-field-5676.fly.dev/scan \
  -H "Content-Type: application/json" \
  -d "{\"scanId\": \"$SCAN_ID\", \"repoUrl\": \"https://github.com/OWNER/REPO\"}"
```

### View Results At
- **Local dev**: `http://localhost:5173/scan/<scanId>`
- **Production**: `https://scanner.vibeship.co/scan/<scanId>`

### Why This Matters
1. Results are saved to Supabase and viewable in the web UI
2. All four scanners run (Opengrep + Trivy + Gitleaks + npm audit)
3. Consistent rule versions from deployed scanner
4. Scan progress is tracked in real-time

### Monitoring Scans
```bash
# Watch scanner logs in real-time
fly logs -a scanner-empty-field-5676

# Get recent logs (no streaming)
fly logs -a scanner-empty-field-5676 --no-tail | tail -100
```

### Common Issues
- **Scan stuck in "scanning"**: Check Fly.io logs for errors
- **Database errors**: Ensure scan row is created with proper schema (target_url, target_url_hash, target_branch)
- **Deployment kills running scans**: Fly.io restarts terminate in-progress scans - wait for completion before deploying

## Architecture

```
vibeship-scanner/
├── src/                    # SvelteKit frontend
│   ├── routes/             # Pages and API routes
│   ├── lib/                # Shared utilities
│   └── app.html            # HTML template
├── scanner/                # Python scanner service (Fly.io)
│   ├── scan.py             # Main scanning orchestrator
│   ├── server.py           # Flask API server
│   ├── rules/              # Semgrep rule files
│   │   ├── core.yaml       # Core security rules
│   │   └── vibeship.yaml   # Extended rules
│   └── Dockerfile          # Scanner container
└── docs/                   # Documentation
```

## Development Commands

```bash
# Start frontend dev server
npm run dev

# Build for production
npm run build

# Deploy scanner to Fly.io
cd scanner && fly deploy --remote-only

# Validate Semgrep rules
semgrep --validate --config scanner/rules/
```

## Key Files

- `scanner/rules/core.yaml` - Core Semgrep security rules
- `scanner/rules/vibeship.yaml` - Extended Semgrep rules
- `scanner/scan.py` - Main scanning logic
- `src/routes/api/scan/+server.ts` - Scan API endpoint
- `src/routes/scan/[id]/+page.svelte` - Scan results page

## Security Knowledge Base

### IMPORTANT: Maintaining SECURITY_COMMONS.md

The `SECURITY_COMMONS.md` file is our **living security vulnerability database**. It must be continuously updated with:

1. **New vulnerability patterns** discovered during:
   - Research on vulnerable applications (DVWA, Juice Shop, etc.)
   - Analysis of GitHub security advisories
   - Review of scan results from real repositories
   - CVE database monitoring

2. **For each vulnerability, document**:
   - CWE ID and name
   - Risk level (Critical/High/Medium/Low)
   - Vulnerable code examples
   - Secure code examples
   - Key prevention points

3. **Use this database to**:
   - Improve Semgrep rules in `scanner/rules/`
   - Enhance scanner explanations
   - Provide accurate fix recommendations
   - Train and validate scanner accuracy

4. **After finding new vulnerabilities**:
   - Add to SECURITY_COMMONS.md with examples
   - Consider adding new Semgrep rules if detectable
   - Update SECURITY_TEST_PROCEDURE.md if needed

### Testing Against Vulnerable Apps

**IMPORTANT**: Follow `SECURITY_TEST_PROCEDURE.md` for systematic scanner improvement.

The test procedure contains **30 vulnerable repositories** organized by priority:
- **Tier 1 (Critical)**: DVWA, Juice Shop, crAPI, NodeGoat, WebGoat, DVNA
- **Tier 2 (Language-Specific)**: RailsGoat, Django.nV, Flask, DSVW, PHP, Java apps
- **Tier 3 (Specialized)**: API security, SSRF, XXE, GraphQL, CI/CD, secrets
- **Tier 4 (Additional)**: Mobile, .NET, Kubernetes, CTF tools

**Iterative Improvement Workflow (MUST FOLLOW)**:

For each vulnerable repository, iterate until all key vulnerabilities are detected:

```
┌─────────────────────────────────────────────────────────────┐
│  1. INITIAL SCAN                                            │
│     - Trigger scan using the scan procedure above           │
│     - Save scan ID for comparison                           │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  2. GAP ANALYSIS                                            │
│     - Review the repo's README/docs for known vulns         │
│     - Check what OWASP Top 10 vulns the repo claims to have │
│     - Compare against our scan findings                     │
│     - List missing detections (gaps)                        │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  3. RULESET UPGRADE                                         │
│     - Create new Opengrep rules for gaps                    │
│     - Validate rules: opengrep --validate -f rule.yaml      │
│     - Deploy: cd scanner && fly deploy --remote-only        │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  4. RE-SCAN & DIFF                                          │
│     - Trigger new scan on same repo (new scan ID)           │
│     - Use the diff tool to compare old vs new findings      │
│     - Verify new rules caught the gaps                      │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│  5. ITERATE OR COMPLETE                                     │
│     - If gaps remain → go back to step 2                    │
│     - If all key vulns detected → document and commit       │
│     - Update SECURITY_TEST_PROCEDURE.md with results        │
└─────────────────────────────────────────────────────────────┘
```

**Gap Analysis Checklist**:
- [ ] SQL Injection (if repo has database)
- [ ] XSS (if repo has web UI)
- [ ] Command Injection (if repo runs shell commands)
- [ ] Path Traversal (if repo handles file paths)
- [ ] SSRF (if repo makes HTTP requests)
- [ ] Insecure Deserialization (if repo deserializes data)
- [ ] Hardcoded Secrets (API keys, passwords)
- [ ] Broken Authentication (weak session handling)
- [ ] Security Misconfiguration (debug mode, CORS)
- [ ] Vulnerable Dependencies (outdated packages)

**Current Progress** (track in SECURITY_TEST_PROCEDURE.md):
- ✅ digininja/DVWA - 18 high findings
- ✅ OWASP/crAPI - 137 findings
- ✅ OWASP/NodeGoat - 353 findings
- ⏳ 27 more repos pending

## Semgrep Rule Guidelines

When adding rules to `scanner/rules/`:

1. **YAML syntax**: Quote patterns containing colons
   ```yaml
   # GOOD
   pattern: 'subprocess.call($CMD, shell=True)'

   # BAD - will fail validation
   pattern: subprocess.call($CMD, shell=True)
   ```

2. **Always validate** before deploying:
   ```bash
   semgrep --validate --config scanner/rules/core.yaml
   ```

3. **Include**:
   - Unique rule ID
   - Clear message
   - Severity (ERROR/WARNING/INFO)
   - Target languages

## Environment Variables

Frontend (.env):
- `PUBLIC_SUPABASE_URL`
- `PUBLIC_SUPABASE_ANON_KEY`
- `SCANNER_API_URL`

Scanner (Fly.io secrets):
- Set via `fly secrets set KEY=value`

## Deployment

**Frontend**: Auto-deploys via Vercel on push to main

**Scanner**: Manual deploy to Fly.io
```bash
cd scanner
fly deploy --remote-only --no-cache
```

## Code Style

- TypeScript for frontend
- Python for scanner
- No comments unless explaining complex logic
- Use existing patterns and utilities

## MCP Servers Configuration

The project has MCP servers configured in `.mcp.json`:

### vibeship-scanner MCP (Custom)
**Location:** `~/.claude/mcp-servers/vibeship-scanner/`
**Python:** `~/.claude/mcp-servers/vibeship-scanner/.venv/Scripts/python.exe`

Tools:
- `scan_repo` - Trigger security scan on GitHub repo
- `get_scan_status` - Check scan progress
- `lookup_cve` - Query NVD for CVE details
- `lookup_ghsa` - Query GitHub Security Advisories
- `get_cwe_info` - Get CWE weakness details + OWASP mapping
- `validate_opengrep_rule` - Validate rule YAML before deployment

### fetch MCP
HTTP requests for custom API queries.

### github MCP
Repository operations, PR creation (requires GITHUB_TOKEN env var).

## Security Rule Development Skill

Use the `security-rule-development` skill when:
- Creating new Opengrep detection rules
- Benchmarking against vulnerable repos
- Researching CVEs/CWEs for rule metadata
- Improving scanner coverage

Skill location: `~/.claude/skills/security-rule-development/`
